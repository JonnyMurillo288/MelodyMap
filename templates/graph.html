<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SixDegreeSpotify</title>
  <style>
    :root { color-scheme: light dark; }
    body {
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      margin: 2rem;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
    }
    h1 { margin: 0; font-size: 1.5rem; }
    .actions { display: flex; gap: .5rem; }
    .btn {
      display: inline-block;
      padding: .5rem .75rem;
      border-radius: 6px;
      text-decoration: none;
      cursor: pointer;
      background: #000;
      color: #fff;
      border: none;
    }
    form { margin-top: 1.25rem; max-width: 720px; }
    label { display: block; margin-top: .75rem; }
    input[type=text], input[type=number] {
      width: 100%;
      padding: .6rem .7rem;
      border: 1px solid #ccc;
      border-radius: 6px;
    }
    .row { display: grid; grid-template-columns: 1fr 1fr; gap: .75rem; }
    .muted { color: #666; }
    #results { margin-top: 1.25rem; }
    .error { color: #b00020; }
    .spinner { display: none; margin-left: 0.75rem; }

    #graph {
      margin-top: 2rem;
      border: 1px solid #444;
      height: 500px;
      position: relative;
    }

    #graph-controls {
      margin-top: 0.75rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.5rem;
      align-items: center;
    }

    #edge-tooltip {
      position: absolute;
      background: #000;
      border: 1px solid #444;
      padding: 6px;
      border-radius: 6px;
      display: none;
      pointer-events: none;
      z-index: 9999;
      max-width: 260px;
    }
    #edge-tooltip img {
      width: 120px;
      height: 120px;
      border-radius: 5px;
      object-fit: cover;
      display: block;
      margin: 0 auto;
    }
    #edge-tooltip .title {
      color: #fff;
      font-size: 12px;
      margin-top: 4px;
      text-align: center;
      word-wrap: break-word;
    }

    #nodeSelect {
      padding: .4rem .5rem;
      border-radius: 6px;
      border: 1px solid #ccc;
      max-width: 260px;
    }
  </style>

  <!-- Graphology + Sigma -->
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
</head>

<body>
<header>
  <h1>SixDegreeSpotify</h1>
  <div class="actions">
    <a class="btn" href="https://buymeacoffee.com/jmurillo">Buy Me a Coffee</a>
    <a class="btn" href="https://jonnymurilloblog543591113.wordpress.com/" target="_blank">Other Projects</a>
    <a class="btn" href="/status" target="_blank">Status</a>
  </div>
</header>

<p class="muted">Find a collaboration path between two artists.</p>

<form id="searchForm">
  <div class="row">
    <label>
      Start Artist
      <input id="startArtist" type="text" placeholder="Eminem" required />
    </label>
    <label>
      Target Artist
      <input id="targetArtist" type="text" placeholder="Taylor Swift" required />
    </label>
  </div>
  <div class="row">
    <label>
      Max Depth (optional)
      <input id="depth" type="number" min="-1" step="1" value="-1" />
    </label>
  </div>
  <button class="btn" type="submit">Search</button>
  <span id="spinner" class="spinner">Searching…</span>
  <div class="muted">Can take up to 30 minutes to process.</div>
  <label>
    <input id="playlistName" type="text" placeholder="Playlist Name (optional)" value = "" />
    <button class="btn" type="button" onclick="startAuthAndPlaylist()">
      Create Spotify Playlist from Connection
    </button>
  </label>
</form>

<div id="results"></div>

<div id="graph"></div>

<div id="graph-controls">
  <button class="btn" id="toggleNeighborsBtn">Hide Neighbors</button>
  <button class="btn" id="collapseNeighborsBtn">Collapse All Neighbors</button>
  <select id="nodeSelect">
    <option value="">Jump to node…</option>
  </select>
  <button class="btn" id="jumpToNodeBtn">Go</button>
</div>

<script>
  /* ================================
     GLOBALS / CONSTANTS
  ===================================*/

  const Graph = window.graphology.Graph;
  const SigmaLib = window.Sigma;

  let graph = null;
  let renderer = null;

  const START_COLOR         = "#2779bd";      // blue
  const TARGET_COLOR        = "#c53030";      // red
  const PATH_NODE_COLOR     = "#2ecc71";      // green (middle nodes)
  const NEIGHBOR_NODE_COLOR = "#888888";      // grey neighbors

  const START_SIZE          = 60;
  const TARGET_SIZE         = 60;
  const PATH_NODE_SIZE      = 35;
  const NEIGHBOR_NODE_SIZE  = 15;

  const NEIGHBOR_EDGE_COLOR = "#666666";
  const NEIGHBOR_EDGE_WIDTH = 1.5;
  const PATH_EDGE_COLOR     = "#2ecc71";

  const HOVER_DIM_COLOR     = "#cccccc";

  // Neighbor lookup:
  // { "eminem": { ID, Name, Neighbors: [...] }, ... }
  let neighborLookupIndex = null;

  // Show/hide neighbors
  let showNeighbors = true;

  // Track expansions per anchor node: name -> { nodes: [], edges: [] }
  const expandedByNode = new Map();

  // Path highlight sets
  let currentPath = [];
  const pathNodeSet = new Set();
  const pathEdgeSet = new Set();

  // Hover state
  const reducerState = {
    hoveredNode: null,
    hoveredNeighbors: new Set(),
  };

  // Direction state for clustered randomness
  const clusterSideByNode = new Map();

  const startInput         = document.getElementById("startArtist");
  const targetInput        = document.getElementById("targetArtist");
  const playlistNameInput  = document.getElementById("playlistName");
  const depthInput         = document.getElementById("depth");
  const resultsDiv         = document.getElementById("results");
  const spinner            = document.getElementById("spinner");
  const toggleNeighborsBtn = document.getElementById("toggleNeighborsBtn");
  const collapseNeighborsBtn = document.getElementById("collapseNeighborsBtn");
  const nodeSelect         = document.getElementById("nodeSelect");
  const jumpToNodeBtn      = document.getElementById("jumpToNodeBtn");

  /* ================================
     SMALL HELPERS
  ===================================*/

  function safeTracksFromStep(step) {
    if (!step) return [];

    // NEW: accept single-track API format
    if (step.track) {
      return [{
        name: step.track || "",
        url: step.trackURL || "",
        id: step.trackID || "",
        recordingID: step.recordingID || "",
      }];
    }

    // OLD: multi-track format
    if (Array.isArray(step.tracks)) {
      return step.tracks.map(t => ({
        name: t.name || "",
        url: t.url || "",
        id: t.id || "",
        recordingID: t.recordingID || "",
      }));
    }

    return [];
  }

  function computeArtistPositionsFromEdges(edges) {
    const pos = new Map();
    let i = 0;
    edges.forEach(edge => {
      if (edge.from && !pos.has(edge.from)) pos.set(edge.from, i++);
      if (edge.to && !pos.has(edge.to)) pos.set(edge.to, i++);
    });
    return pos;
  }

  function edgeWidthFromCount(count, isPath) {
    // tweak this to taste
    if (isPath) {
      return Math.min(4 + count * 4, 40);
    }
    return Math.min(NEIGHBOR_EDGE_WIDTH + count * 1.2, 20);
  }

  /* ================================
     NEIGHBOR LOOKUP
  ===================================*/

  async function loadNeighborLookup() {
    if (neighborLookupIndex) return neighborLookupIndex;

    try {
      const res = await fetch("/NeighborLookup.json?ts=" + Date.now());
      if (!res.ok) {
        console.error("Failed to load NeighborLookup.json:", await res.text());
        neighborLookupIndex = {};
        return neighborLookupIndex;
      }

      const raw = await res.json();
      const index = {};

      if (Array.isArray(raw)) {
        raw.forEach(entry => {
          if (!entry || !entry.Name) return;
          const key = entry.Name.toLowerCase();
          index[key] = entry;
        });
      } else if (typeof raw === "object" && raw !== null) {
        Object.keys(raw).forEach(k => {
          const entry = raw[k];
          if (!entry) return;
          const name = entry.Name || k;
          index[name.toLowerCase()] = entry;
        });
      }

      neighborLookupIndex = index;
      return neighborLookupIndex;
    } catch (err) {
      console.error("Error loading NeighborLookup.json:", err);
      neighborLookupIndex = {};
      return neighborLookupIndex;
    }
  }

  function findNeighborsEntryByName(name) {
    if (!neighborLookupIndex || !name) return null;
    const lc = name.toLowerCase();
    return neighborLookupIndex[lc] || null;
  }

  /* ================================
     GRAPH HELPERS
  ===================================*/

  function ensureArtistNode(name, start, target, posMap) {
    if (!name) return;

    if (graph.hasNode(name)) {
      graph.setNodeAttribute(name, "role", "path");
      if (name === start) {
        graph.setNodeAttribute(name, "color", START_COLOR);
        graph.setNodeAttribute(name, "size", START_SIZE);
      } else if (name === target) {
        graph.setNodeAttribute(name, "color", TARGET_COLOR);
        graph.setNodeAttribute(name, "size", TARGET_SIZE);
      } else {
        graph.setNodeAttribute(name, "color", PATH_NODE_COLOR);
        graph.setNodeAttribute(name, "size", PATH_NODE_SIZE);
      }
      return;
    }

    let color = PATH_NODE_COLOR;
    let size  = PATH_NODE_SIZE;
    if (name === start) { color = START_COLOR; size = START_SIZE; }
    else if (name === target) { color = TARGET_COLOR; size = TARGET_SIZE; }

    let x = Math.random() * 6 - 3;
    let y = Math.random() * 6 - 3;
    if (posMap && posMap.has(name)) {
      const idx = posMap.get(name);
      x = idx * 10;
      y = Math.sin(idx) * 0.3;
    }

    graph.addNode(name, {
      label: name,
      size,
      color,
      x,
      y,
      role: "path",
    });
  }

  function randomClusterSideForNode(node) {
    if (clusterSideByNode.has(node)) return clusterSideByNode.get(node);

    const start = startInput.value.trim();
    const target = targetInput.value.trim();

    let side;
    if (node === start) {
      side = "left";
    } else if (node === target) {
      side = "right";
    } else {
      const ud = ["up", "down"];
      side = ud[Math.floor(Math.random() * ud.length)];
    }

    clusterSideByNode.set(node, side);
    return side;
  }

  function positionNeighborAroundAnchor(anchor, idx, total, side) {
    const anchorAttrs = graph.getNodeAttributes(anchor);
    const ax = anchorAttrs.x || 0;
    const ay = anchorAttrs.y || 0;

    const t = total <= 1 ? 0 : (idx / (total - 1)) - 0.5;
    const baseRadius = 8 + Math.random() * 2 + Math.log(idx + 2);
    const jitterR = (Math.random() - 0.5) * 2;
    const jitterAngle = (Math.random() - 0.5) * .9;

    let baseAngle;
    switch (side) {
      case "left":  baseAngle = Math.PI;         break;
      case "right": baseAngle = 0;               break;
      case "up":    baseAngle = -Math.PI / 2;    break;
      case "down":  baseAngle =  Math.PI / 2;    break;
      default:      baseAngle = Math.random() * Math.PI * 2;
    }

    const spread = 0.9 + Math.random() * 1.1;
    const angle = baseAngle + t * spread + jitterAngle;
    const radius = baseRadius + jitterR;

    const x = ax + Math.cos(angle) * radius;
    const y = ay + Math.sin(angle) * radius;

    return { x, y };
  }

  /* ================================
     AGGREGATION LOGIC
     - collapse multiple tracks into a single edge
  ===================================*/

  function aggregatePathEdges(pathArray) {
    const map = new Map();
    if (!Array.isArray(pathArray)) return [];

    pathArray.forEach(step => {
      if (!step || !step.from || !step.to) return;
      const key = `${step.from}|||${step.to}`;

      if (!map.has(key)) {
        map.set(key, {
          from: step.from,
          to: step.to,
          tracks: [],
        });
      }

      const edge = map.get(key);
      const tracks = safeTracksFromStep(step);
      tracks.forEach(t => edge.tracks.push(t));
    });

    return Array.from(map.values());
  }

  function aggregateNeighborEntries(neighborsArray) {
    const map = new Map();
    if (!Array.isArray(neighborsArray)) return [];

    neighborsArray.forEach(nb => {
      if (!nb) return;

      const nbName = nb.Name || nb.ID;
      if (!nbName) return;

      const key = nbName;

      if (!map.has(key)) {
        map.set(key, {
          id: nb.ID,
          name: nbName,
          tracks: [],
          firstTrack: null,
        });
      }

      const agg = map.get(key);

      if (Array.isArray(nb.Tracks)) {
        nb.Tracks.forEach(t => {
          const trackObj = {
            name: t.Name,
            url: t.PhotoURL,
            id: t.ID,
            recordingID: t.RecordingID,
          };
          agg.tracks.push(trackObj);
          if (!agg.firstTrack) agg.firstTrack = trackObj;
        });
      }
    });

    return Array.from(map.values());
  }

  /* ================================
     NEIGHBOR EXPANSION / COLLAPSE
  ===================================*/

  async function expandNodeNeighbors(anchorName) {
    if (!anchorName) return;

    await loadNeighborLookup();

    const entry = findNeighborsEntryByName(anchorName);
    if (!entry || !Array.isArray(entry.Neighbors) || entry.Neighbors.length === 0) {
      console.warn("No neighbors for", anchorName);
      return;
    }

    if (!graph.hasNode(anchorName)) {
      graph.addNode(anchorName, {
        label: anchorName,
        size: PATH_NODE_SIZE,
        color: PATH_NODE_COLOR,
        x: Math.random() * 6 - 3,
        y: Math.random() * 6 - 3,
        role: "path",
      });
    }

    const aggregatedNeighbors = aggregateNeighborEntries(entry.Neighbors);
    const createdNodes = [];
    const createdEdges = [];

    const side = randomClusterSideForNode(anchorName);
    const total = aggregatedNeighbors.length;

    aggregatedNeighbors.forEach((agg, idx) => {
      const nbName = agg.name;
      if (!nbName) return;

      let isNewNode = false;
      if (!graph.hasNode(nbName)) {
        const pos = positionNeighborAroundAnchor(anchorName, idx, total, side);
        graph.addNode(nbName, {
          label: nbName,
          size: NEIGHBOR_NODE_SIZE,
          color: NEIGHBOR_NODE_COLOR,
          x: pos.x,
          y: pos.y,
          role: "neighbor",
        });
        createdNodes.push(nbName);
        isNewNode = true;
      } else {
        const role = graph.getNodeAttribute(nbName, "role");
        if (!role || role === "neighbor") {
          graph.setNodeAttribute(nbName, "role", "neighbor");
          graph.setNodeAttribute(nbName, "color", NEIGHBOR_NODE_COLOR);
          graph.setNodeAttribute(nbName, "size", NEIGHBOR_NODE_SIZE);
        }
      }

      const trackCount = agg.tracks.length;
      const edgeId = `${anchorName}->${nbName}`;

      const label =
        trackCount === 1
          ? (agg.tracks[0].name || `${trackCount} track`)
          : `${trackCount} tracks`;

      const width = edgeWidthFromCount(trackCount, false);
      const firstTrack = agg.tracks[0] || {};

      if (!graph.hasEdge(edgeId)) {
        graph.addEdgeWithKey(edgeId, anchorName, nbName, {
          label: label,
          color: NEIGHBOR_EDGE_COLOR,
          size: width,
          role: "neighbor",
          tracks: agg.tracks,
          trackCount: trackCount,
          trackURL: firstTrack.url || "",
        });
        createdEdges.push(edgeId);
      } else if (isNewNode) {
        graph.setEdgeAttribute(edgeId, "role", "neighbor");
      }
    });

    if (createdNodes.length || createdEdges.length) {
      const existing = expandedByNode.get(anchorName) || { nodes: [], edges: [] };
      expandedByNode.set(anchorName, {
        nodes: existing.nodes.concat(createdNodes),
        edges: existing.edges.concat(createdEdges),
      });
    }

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  function collapseNodeNeighbors(anchorName) {
    const record = expandedByNode.get(anchorName);
    if (!record) return;

    record.edges.forEach(eId => {
      if (graph.hasEdge(eId)) graph.dropEdge(eId);
    });

    record.nodes.forEach(nId => {
      if (graph.hasNode(nId)) graph.dropNode(nId);
    });

    expandedByNode.delete(anchorName);

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  function toggleNodeNeighbors(anchorName) {
    if (expandedByNode.has(anchorName)) {
      collapseNodeNeighbors(anchorName);
    } else {
      expandNodeNeighbors(anchorName);
    }
  }

  async function expandNeighborsForPath(path) {
    if (!Array.isArray(path)) return;
    const nodeSet = new Set();
    path.forEach(step => {
      if (step.from) nodeSet.add(step.from);
      if (step.to)   nodeSet.add(step.to);
    });

    for (const name of nodeSet) {
      await expandNodeNeighbors(name);
    }
  }

  function collapseAllNeighbors() {
    if (!graph) return;

    graph.forEachEdge((edge, attrs) => {
      if (attrs.role === "neighbor") {
        graph.dropEdge(edge);
      }
    });

    graph.forEachNode((node, attrs) => {
      if (attrs.role === "neighbor") {
        graph.dropNode(node);
      }
    });

    expandedByNode.clear();

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  /* ================================
     INIT GRAPH + RENDERER
  ===================================*/

  function initGraph(start, target) {
    const container = document.getElementById("graph");

    if (renderer) {
      renderer.kill();
      renderer = null;
    }

    graph = new Graph();
    container.innerHTML = "";

    const tooltip = document.createElement("div");
    tooltip.id = "edge-tooltip";
    container.appendChild(tooltip);

    if (start) {
      graph.addNode(start, {
        label: start,
        size: START_SIZE,
        color: START_COLOR,
        x: 0,
        y: 0,
        role: "path",
        labelWeight: "bold"
      });
    }

    renderer = new SigmaLib(graph, container, {
      renderLabels: true,
      renderEdgeLabels: true,
      labelDensity: 0.7,
      labelColor: { color: "#ffffffff" },
    });

    refreshNodeDropdown();

    renderer.setSetting("nodeReducer", (node, data) => {
      const res = { ...data };

      if (!showNeighbors && data.role === "neighbor") {
        res.hidden = true;
        return res;
      }

      const isHovered = node === reducerState.hoveredNode;

      // hovered node highlight
      if (isHovered) {
        res.color = "#333333";         // dark grey
        res.labelColor = "#ff0000ff";  // red text
        res.size = data.size * 1.15;
        return res;
      }

      if (reducerState.hoveredNode) {
        if (pathNodeSet.has(reducerState.hoveredNode) && pathNodeSet.size > 0) {
          // full-path highlighting
          if (!pathNodeSet.has(node)) {
            res.color = HOVER_DIM_COLOR;
            res.size = data.size * 0.7;
            res.label = "";
          }
        } else {
          // local neighbors highlighting
          const isNeighbor =
            node === reducerState.hoveredNode ||
            reducerState.hoveredNeighbors.has(node);

          if (!isNeighbor) {
            res.color = HOVER_DIM_COLOR;
            res.size = data.size * 0.7;
            res.label = "";
          }
        }
      }

      return res;
    });

    renderer.setSetting("edgeReducer", (edge, data) => {
      const res = { ...data };

      if (!showNeighbors && data.role === "neighbor") {
        res.hidden = true;
        return res;
      }

      if (reducerState.hoveredNode) {
        if (pathNodeSet.has(reducerState.hoveredNode) && pathEdgeSet.size > 0) {
          if (!pathEdgeSet.has(edge)) {
            res.hidden = true;
          }
        } else {
          const [src, dst] = graph.extremities(edge);
          const connected =
            src === reducerState.hoveredNode ||
            dst === reducerState.hoveredNode ||
            reducerState.hoveredNeighbors.has(src) ||
            reducerState.hoveredNeighbors.has(dst);

          if (!connected) {
            res.hidden = true;
          }
        }
      }

      return res;
    });

    renderer.on("enterNode", ({ node }) => {
      reducerState.hoveredNode = node;
      reducerState.hoveredNeighbors = new Set(graph.neighbors(node));
      renderer.refresh({ skipIndexation: true });
    });

    renderer.on("leaveNode", () => {
      reducerState.hoveredNode = null;
      reducerState.hoveredNeighbors.clear();
      renderer.refresh({ skipIndexation: true });
    });

    renderer.on("clickNode", ({ node }) => {
      const label = graph.getNodeAttribute(node, "label") || node;
      toggleNodeNeighbors(label);
    });

    renderer.on("enterEdge", ({ edge }) => {
      const attr = graph.getEdgeAttributes(edge);
      const tracks = attr.tracks || [];

      if (!tracks.length) {
        tooltip.style.display = "none";
        return;
      }

      const firstWithImage = tracks.find(t => t.url) || {};
      const displayTitle =
        tracks.length === 1
          ? (tracks[0].name || "Track")
          : `${tracks.length} tracks`;

      let html = "";
      if (firstWithImage.url) {
        html += `<img src="${firstWithImage.url}">`;
      }
      html += `<div class="title">${displayTitle}</div>`;

      if (tracks.length > 1) {
        const names = tracks
          .map(t => t.name)
          .filter(Boolean)
          .slice(0, 6);
        if (names.length) {
          html += `<div class="title">${names.join("<br>")}</div>`;
        }
      }

      tooltip.innerHTML = html;
      tooltip.style.display = "block";
    });

    renderer.on("leaveEdge", () => {
      tooltip.style.display = "none";
    });

    renderer.on("mousemove", e => {
      const tooltip = document.getElementById("edge-tooltip");
      if (!tooltip) return;
      tooltip.style.left = (e.event.x + 15) + "px";
      tooltip.style.top  = (e.event.y + 15) + "px";
    });
  }

  /* ================================
     PATH RENDERING
  ===================================*/

  function addPathToGraph(path, start, target) {
    if (!graph || !renderer || !Array.isArray(path)) return;

    const aggregatedEdges = aggregatePathEdges(path);
    currentPath = aggregatedEdges;
    pathNodeSet.clear();
    pathEdgeSet.clear();

    const posMap = computeArtistPositionsFromEdges(aggregatedEdges);

    aggregatedEdges.forEach(edge => {
      const from = edge.from;
      const to   = edge.to;
      const tracks = edge.tracks || [];
      if (!from || !to) return;

      const trackCount = tracks.length || 1;
      const width = edgeWidthFromCount(trackCount, true);

      ensureArtistNode(from, start, target, posMap);
      ensureArtistNode(to,   start, target, posMap);

      const edgeId = `${from}->${to}`;

      pathNodeSet.add(from);
      pathNodeSet.add(to);
      pathEdgeSet.add(edgeId);

      const label =
        trackCount === 1
          ? (tracks[0].name || `${trackCount} track`)
          : `${trackCount} tracks`;

      const firstTrack = tracks[0] || {};

      if (graph.hasEdge(edgeId)) {
        graph.setEdgeAttribute(edgeId, "color", PATH_EDGE_COLOR);
        graph.setEdgeAttribute(edgeId, "size", width);
        graph.setEdgeAttribute(edgeId, "role", "path");
        graph.setEdgeAttribute(edgeId, "label", label);
        graph.setEdgeAttribute(edgeId, "tracks", tracks);
        graph.setEdgeAttribute(edgeId, "trackCount", trackCount);
        graph.setEdgeAttribute(edgeId, "trackURL", firstTrack.url || "");
      } else {
        graph.addEdgeWithKey(edgeId, from, to, {
          label: label,
          size: width,
          color: PATH_EDGE_COLOR,
          role: "path",
          tracks: tracks,
          trackCount: trackCount,
          trackURL: firstTrack.url || "",
        });
      }
    });

    refreshNodeDropdown();
    renderer.refresh();
  }

  /* ================================
     DROPDOWN / CAMERA
  ===================================*/

  function refreshNodeDropdown() {
    if (!graph) return;
    const nodes = [];
    graph.forEachNode((node, attrs) => {
      nodes.push(attrs.label || node);
    });
    nodes.sort((a, b) => a.localeCompare(b));

    const current = nodeSelect.value;
    let html = '<option value="">Jump to node…</option>';
    for (const name of nodes) {
      const selected = name === current ? ' selected' : '';
      html += `<option value="${name}"${selected}>${name}</option>`;
    }
    nodeSelect.innerHTML = html;
  }

  function jumpToNode(name) {
    if (!renderer || !graph || !name) return;
    if (!graph.hasNode(name)) return;

    const cam = renderer.getCamera();
    const pos = renderer.getNodeDisplayData(name);
    if (!pos) return;

    cam.animate(
      { x: pos.x, y: pos.y, ratio: 0.1 },
      { duration: 600 }
    );
  }

  /* ================================
     SEARCH WORKFLOW
  ===================================*/

  async function runSearch() {
    const start = startInput.value.trim();
    const target = targetInput.value.trim();
    const depth = Number(depthInput.value || -1);

    if (!start || !target) {
      resultsDiv.innerHTML = "<p class='error'>Start and Target are required.</p>";
      return;
    }

    expandedByNode.clear();
    pathNodeSet.clear();
    pathEdgeSet.clear();
    clusterSideByNode.clear();

    initGraph(start, target);

    resultsDiv.innerHTML = "";
    spinner.style.display = "inline";

    try {
      const res = await fetch("/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ start, target, depth }),
      });

      spinner.style.display = "none";

      if (!res.ok) {
        const txt = await res.text();
        resultsDiv.innerHTML = `<p class="error">Request failed: ${txt}</p>`;
        return;
      }

      const data = await res.json();

      if (data.message) {
        resultsDiv.innerHTML = `<p class="muted">${data.message}</p>`;
        return;
      }

      let pathHtml = `<p><strong>Start:</strong> ${data.start}<br>
        <strong>Target:</strong> ${data.target}<br>
        <strong>Hops:</strong> ${data.hops}</p>`;

      if (data.path && data.path.length > 0) {
        pathHtml += `<p><strong>Path:</strong></p><ol>`;
        data.path.forEach((step, i) => {
          const from = step.from || "";
          const to   = step.to || "";
          let trackList = "";
          if (step.tracks && step.tracks.length > 0) {
            console.log("Step tracks:", step.tracks);
            trackList = step.tracks.map(t => t.name).join(", ");
          } else {
            trackList = "No track data";
          }
          pathHtml += `<li>${from} —[${trackList}]→ ${to}</li>`;        });
        pathHtml += `</ol>`;
      }

      resultsDiv.innerHTML = pathHtml;

      addPathToGraph(data.path, data.start, data.target);
      await expandNeighborsForPath(data.path);
      collapseAllNeighbors();
      renderer.refresh();
    } catch (err) {
      spinner.style.display = "none";
      resultsDiv.innerHTML = `<p class="error">Request failed: ${err}</p>`;
    }
  }

  /* ================================
     Create Playlist Workflow
  ===================================*/

  function startAuthAndPlaylist() {
    window.open('/auth', '_blank', 'width=600,height=800');

    fetch('/createPlaylist', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playlistName: "My Generated Playlist" })
    })
    .then(res => res.json())
    .then(data => {
        console.log("Playlist created:", data);
        alert("Playlist created: " + data.url);
    })
    .catch(err => {
        console.error("Error creating playlist:", err);
        alert("Error creating playlist");
    });
  }

  document.getElementById("searchForm").addEventListener("submit", (e) => {
    e.preventDefault();
    runSearch();
  });

  toggleNeighborsBtn.addEventListener("click", () => {
    showNeighbors = !showNeighbors;
    toggleNeighborsBtn.textContent = showNeighbors ? "Hide Neighbors" : "Show Neighbors";
    if (renderer) renderer.refresh({ skipIndexation: true });
  });

  collapseNeighborsBtn.addEventListener("click", () => {
    collapseAllNeighbors();
  });

  jumpToNodeBtn.addEventListener("click", () => {
    const name = nodeSelect.value;
    if (name) jumpToNode(name);
  });
</script>

</body>
</html>
