<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>SixDegreeSpotify</title>
  <style>
    :root {
      color-scheme: light dark;
      --bg: #050712;
      --card-bg: rgba(10, 10, 20, 0.96);
      --card-border: rgba(255, 255, 255, 0.06);
      --accent: #10b981;
      --accent-soft: rgba(16, 185, 129, 0.12);
      --accent-strong: #22c55e;
      --error: #f97373;
      --text-main: #e5e7eb;
      --text-muted: #9ca3af;
      --chip-bg: rgba(55, 65, 81, 0.7);
    }
    * {
      box-sizing: border-box;
    }
    body {
      margin: 0;
      min-height: 100vh;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text-main);
      background:
        radial-gradient(circle at 10% 10%, #111827 0, transparent 50%),
        radial-gradient(circle at 90% 90%, #111827 0, transparent 55%),
        radial-gradient(circle at 20% 80%, #0f766e 0, transparent 45%),
        var(--bg);
      padding: 2rem;
      display: flex;
      justify-content: center;
    }
    .page {
      width: 100%;
      max-width: 1200px;
    }
    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 1.25rem;
    }
    h1 {
      margin: 0;
      font-size: 1.6rem;
      letter-spacing: 0.03em;
      display: flex;
      align-items: center;
      gap: 0.4rem;
    }
    h1 span.logo-dot {
      width: 9px;
      height: 9px;
      border-radius: 50%;
      background: radial-gradient(circle at 30% 30%, #ffffff, var(--accent));
      box-shadow: 0 0 12px rgba(16, 185, 129, 0.9);
    }
    .header-subtitle {
      font-size: 0.9rem;
      color: var(--text-muted);
      margin-top: 0.2rem;
    }
    .header-left {
      display: flex;
      flex-direction: column;
      gap: 0.2rem;
    }
    .header-badges {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-top: 0.15rem;
    }
    .badge {
      padding: 0.12rem 0.5rem;
      border-radius: 999px;
      font-size: 0.7rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      background: rgba(31, 41, 55, 0.7);
      border: 1px solid rgba(75, 85, 99, 0.9);
      color: var(--text-muted);
    }
    .badge-accent {
      background: var(--accent-soft);
      border-color: rgba(16, 185, 129, 0.4);
      color: var(--accent-strong);
    }

    .actions {
      display: flex;
      gap: .5rem;
      flex-wrap: wrap;
    }
    .btn {
      display: inline-flex;
      align-items: center;
      justify-content: center;
      padding: .5rem .85rem;
      border-radius: 999px;
      text-decoration: none;
      cursor: pointer;
      font-size: 0.85rem;
      border: 1px solid rgba(255,255,255,0.08);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      backdrop-filter: blur(10px);
      transition: background 0.15s ease, transform 0.1s ease, box-shadow 0.15s ease, border-color 0.15s ease;
    }
    .btn:hover {
      background: rgba(31, 41, 55, 0.9);
      transform: translateY(-1px);
      box-shadow: 0 8px 20px rgba(0, 0, 0, 0.35);
      border-color: rgba(148, 163, 184, 0.5);
    }
    .btn-primary {
      background: linear-gradient(135deg, #22c55e, #0ea5e9);
      border-color: transparent;
      color: #0b1120;
      font-weight: 600;
      box-shadow: 0 6px 18px rgba(45, 212, 191, 0.4);
    }
    .btn-primary:hover {
      background: linear-gradient(135deg, #4ade80, #38bdf8);
      box-shadow: 0 10px 24px rgba(45, 212, 191, 0.55);
    }
    .btn-ghost {
      background: transparent;
      border-color: rgba(148, 163, 184, 0.35);
      color: var(--text-muted);
    }
    .btn-ghost:hover {
      background: rgba(15, 23, 42, 0.85);
      color: var(--text-main);
    }

    .layout {
      display: grid;
      grid-template-columns: minmax(0, 320px) minmax(0, 1fr);
      gap: 1.25rem;
      align-items: flex-start;
    }
    @media (max-width: 900px) {
      .layout {
        grid-template-columns: minmax(0,1fr);
      }
    }

    .card {
      background: var(--card-bg);
      border-radius: 18px;
      border: 1px solid var(--card-border);
      padding: 1.25rem 1.2rem;
      box-shadow:
        0 12px 40px rgba(0, 0, 0, 0.5),
        0 0 0 1px rgba(15, 23, 42, 0.9);
      backdrop-filter: blur(18px);
    }

    .card-title {
      font-size: 1rem;
      font-weight: 600;
      margin: 0 0 0.4rem;
    }
    .card-subtitle {
      font-size: 0.8rem;
      color: var(--text-muted);
      margin-bottom: 0.9rem;
    }

    form {
      margin-top: 0.25rem;
    }
    label {
      display: block;
      margin-top: .75rem;
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      color: var(--text-muted);
    }
    .row {
      display: grid;
      grid-template-columns: 1fr;
      gap: .75rem;
    }
    @media (min-width: 700px) {
      .row {
        grid-template-columns: 1fr 1fr;
      }
    }

    .field-group {
      margin-top: 0.25rem;
      position: relative;
    }

    .input-shell {
      position: relative;
    }
    input[type=text],
    input[type=number] {
      width: 100%;
      padding: .6rem .7rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.9);
      color: var(--text-main);
      font-size: 0.86rem;
      outline: none;
      box-shadow: 0 0 0 1px transparent;
      transition: border-color 0.15s ease, box-shadow 0.15s ease, background 0.15s ease;
    }
    input[type=text]::placeholder,
    input[type=number]::placeholder {
      color: rgba(148, 163, 184, 0.7);
    }
    input[type=text]:focus,
    input[type=number]:focus {
      border-color: rgba(45, 212, 191, 0.8);
      box-shadow: 0 0 0 1px rgba(45, 212, 191, 0.9);
      background: rgba(15, 23, 42, 0.98);
    }

    .muted {
      color: var(--text-muted);
      font-size: 0.78rem;
      margin-top: 0.45rem;
    }
    #results {
      margin-top: 1rem;
      font-size: 0.85rem;
      max-height: 260px;
      overflow: auto;
      padding-right: 0.1rem;
    }
    #results strong {
      color: var(--accent-strong);
    }
    .path-list {
      margin: 0.4rem 0 0;
      padding-left: 1.2rem;
      font-size: 0.84rem;
    }
    .path-list li {
      margin-bottom: 0.15rem;
    }
    .path-chip {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      background: var(--chip-bg);
      border-radius: 999px;
      padding: 0.15rem 0.45rem;
      font-size: 0.7rem;
      margin-left: 0.3rem;
      color: var(--text-muted);
    }
    .path-chip span {
      opacity: 0.85;
    }

    .error {
      color: var(--error);
    }
    .spinner {
      display: none;
      margin-left: 0.75rem;
      font-size: 0.8rem;
      color: var(--accent-strong);
    }

    .search-actions {
      display: flex;
      align-items: center;
      gap: 0.6rem;
      margin-top: 1rem;
      flex-wrap: wrap;
    }

    .pill {
      display: inline-flex;
      align-items: center;
      gap: 0.35rem;
      padding: 0.2rem 0.6rem;
      border-radius: 999px;
      background: rgba(15,23,42,0.9);
      border: 1px solid rgba(31,41,55,0.9);
      font-size: 0.7rem;
      color: var(--text-muted);
    }

    /* Autocomplete dropdown */
    .autocomplete-container {
      position: relative;
    }
    .autocomplete-list {
      position: absolute;
      left: 0;
      right: 0;
      top: calc(100% + 4px);
      z-index: 50;
      background: rgba(15, 23, 42, 0.98);
      border-radius: 14px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      box-shadow:
        0 20px 40px rgba(0, 0, 0, 0.6),
        0 0 0 1px rgba(15, 23, 42, 0.8);
      max-height: 260px;
      overflow-y: auto;
      padding: 4px;
      display: none;
    }
    .autocomplete-item {
      padding: 0.42rem 0.55rem;
      border-radius: 10px;
      font-size: 0.86rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.4rem;
      cursor: pointer;
      color: var(--text-main);
      transition: background 0.12s ease, transform 0.05s ease;
    }
    .autocomplete-item:hover,
    .autocomplete-item[aria-selected="true"] {
      background: rgba(31, 41, 55, 0.95);
      transform: translateY(-0.5px);
    }
    .autocomplete-left {
      display: flex;
      align-items: center;
      gap: 0.4rem;
      min-width: 0;
    }
    .artist-badge {
      width: 22px;
      height: 22px;
      border-radius: 999px;
      background: radial-gradient(circle at 30% 30%, #ffffff, #6366f1);
      box-shadow: 0 0 14px rgba(79, 70, 229, 0.7);
      flex-shrink: 0;
    }
    .autocomplete-name {
      white-space: nowrap;
      text-overflow: ellipsis;
      overflow: hidden;
    }
    .autocomplete-tag {
      font-size: 0.68rem;
      color: var(--text-muted);
      text-transform: uppercase;
      letter-spacing: 0.04em;
    }
    .highlight {
      color: var(--accent-strong);
    }

    /* Graph section */
    #graph-card {
      padding: 0.7rem 0.8rem 0.8rem;
      position: relative;
      overflow: hidden;
    }
    #graph {
      margin-top: 0.4rem;
      border-radius: 16px;
      border: 1px solid rgba(55, 65, 81, 0.9);
      height: min(80vh, 820px);
      width: 100%;
      position: relative;
      background:
        radial-gradient(circle at 20% 20%, rgba(45, 212, 191, 0.22), transparent 55%),
        radial-gradient(circle at 65% 80%, rgba(59, 130, 246, 0.22), transparent 60%),
        radial-gradient(circle at 90% 10%, rgba(244, 63, 94, 0.18), transparent 55%),
        #020617;
      overflow: hidden;
    }
    #graph::before {
      content: "";
      position: absolute;
      inset: -40%;
      background-image:
        radial-gradient(circle, rgba(148, 163, 184, 0.3) 1px, transparent 0);
      background-size: 24px 24px;
      opacity: 0.22;
      pointer-events: none;
    }

    #graph-controls {
      margin-top: 0.7rem;
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 0.7rem;
      font-size: 0.85rem;

      /* NEW: make it stretch full width */
      width: 100%;
    }
    .graph-controls-left,
    .graph-controls-right {
      display: flex;
      align-items: center;
      gap: 0.6rem;

      /* NEW: expand so dropdown stays visible */
      flex: 1;
      justify-content: flex-end;
    }
    #nodeSelect {
      padding: .45rem .75rem;
      border-radius: 999px;
      border: 1px solid rgba(148, 163, 184, 0.7);
      background: rgba(15, 23, 42, 0.95);
      color: var(--text-main);
      font-size: 0.9rem;
      max-width: 320px;  /* wider dropdown */
      width: 320px;      /* force width */
      outline: none;
    }

    #edge-tooltip {
      position: absolute;
      background: rgba(15, 23, 42, 0.98);
      border: 1px solid rgba(55, 65, 81, 0.95);
      padding: 6px;
      border-radius: 12px;
      display: none;
      pointer-events: none;
      z-index: 9999;
      max-width: 260px;
      box-shadow:
        0 10px 30px rgba(0, 0, 0, 0.8),
        0 0 0 1px rgba(15, 23, 42, 0.9);
    }
    #edge-tooltip img {
      width: 110px;
      height: 110px;
      border-radius: 10px;
      object-fit: cover;
      display: block;
      margin: 0 auto;
    }
    #edge-tooltip .title {
      color: var(--text-main);
      font-size: 12px;
      margin-top: 4px;
      text-align: center;
      word-wrap: break-word;
    }
    #edge-tooltip .subtitle {
      color: var(--text-muted);
      font-size: 11px;
      margin-top: 3px;
      text-align: center;
      word-wrap: break-word;
    }

    .graph-legend {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-bottom: 0.3rem;
      flex-wrap: wrap;
    }
    .legend-dot {
      width: 8px;
      height: 8px;
      border-radius: 999px;
      flex-shrink: 0;
    }
    .legend-item {
      display: inline-flex;
      align-items: center;
      gap: 0.25rem;
      font-size: 0.7rem;
      color: var(--text-muted);
      padding: 0.15rem 0.45rem;
      background: rgba(15, 23, 42, 0.8);
      border-radius: 999px;
      border: 1px solid rgba(55, 65, 81, 0.9);
    }
  </style>

  <!-- Graphology + Sigma -->
  <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/sigma@2.4.0/build/sigma.min.js"></script>
</head>

<body>
<div class="page">
  <header>
    <div class="header-left">
      <h1><span class="logo-dot"></span>SixDegreeSpotify</h1>
      <div class="header-subtitle">
        Visualize collaboration paths between artists & generate playlists from the links.
      </div>
      <div class="header-badges">
        <span class="badge badge-accent">MusicBrainz + Spotify</span>
        <span class="badge">Galaxy Graph View</span>
        <span class="badge">Track-weighted edges</span>
      </div>
    </div>
    <div class="actions">
      <a class="btn btn-ghost" href="https://jonnymurilloblog543591113.wordpress.com/" target="_blank">Other Projects</a>
      <a class="btn btn-ghost" href="/status" target="_blank">Status</a>
      <a class="btn btn-primary" href="https://buymeacoffee.com/jmurillo" target="_blank">Buy Me a Coffee</a>
    </div>
  </header>

  <div class="layout">
    <!-- Left: search + results -->
    <section class="card">
      <h2 class="card-title">Search for a collaboration path</h2>
      <div class="card-subtitle">
        Pick two artists. I’ll resolve them via MusicBrainz, run a multi-hop BFS over collaborations,
        and then render the strongest links in the graph.
      </div>

      <form id="searchForm">
        <div class="row">
          <div class="field-group">
            <label for="startArtist">Start Artist</label>
            <div class="autocomplete-container">
              <input id="startArtist" type="text" placeholder="Eminem" autocomplete="off" />
              <div class="autocomplete-list" data-for="startArtist"></div>
            </div>
          </div>
          <div class="field-group">
            <label for="targetArtist">Target Artist</label>
            <div class="autocomplete-container">
              <input id="targetArtist" type="text" placeholder="Taylor Swift" autocomplete="off" />
              <div class="autocomplete-list" data-for="targetArtist"></div>
            </div>
          </div>
        </div>

        <div class="row">
          <div class="field-group">
            <label for="depth">Max Depth (optional)</label>
            <div class="input-shell">
              <input id="depth" type="number" min="-1" step="1" value="-1" />
            </div>
            <div class="muted">
              -1 = no explicit limit. Use a smaller depth (e.g. 4–6) for faster, tighter paths.
            </div>
          </div>
        </div>

        <div class="search-actions">
          <button class="btn btn-primary" type="submit">Search Path</button>
          <span id="spinner" class="spinner">Searching graph…</span>

          <div class="pill">
            <span>ℹ︎</span>
            <span>Heavy queries can take a while. Try closer artists for a quick look.</span>
          </div>
        </div>

        <div class="field-group" style="margin-top: 1.1rem;">
          <label for="playlistName">Spotify Playlist (optional)</label>
          <div class="row">
            <div>
              <input id="playlistName" type="text" placeholder="Playlist Name (optional)" value="" />
            </div>
            <div>
              <button class="btn btn-ghost" type="button" onclick="startAuthAndPlaylist()">
                Create Spotify Playlist from Connection
              </button>
            </div>
          </div>
          <div class="muted">
            After a successful search, I’ll try to match each link’s track on Spotify to build a playlist.
          </div>
        </div>
      </form>

      <div id="results"></div>
    </section>

    <!-- Right: graph -->
    <section class="card" id="graph-card">
      <div style="display:flex;justify-content:space-between;align-items:center;gap:0.5rem;">
        <div>
          <h2 class="card-title">Collaboration Galaxy</h2>
          <div class="card-subtitle">
            Each node is an artist; edge thickness scales with the number of shared tracks.
            Hover to isolate; click to expand neighbors.
          </div>
        </div>
      </div>

      <div id="graph"></div>

      <div id="graph-controls">
        <div class="graph-controls-left">
          <button class="btn btn-ghost" id="toggleNeighborsBtn">Hide Neighbors</button>
          <button class="btn btn-ghost" id="collapseNeighborsBtn">Collapse Neighbors</button>
        </div>
        <div class="graph-controls-right">
          <div class="graph-legend">
            <span class="legend-item">
              <span class="legend-dot" style="background:#2779bd;"></span> Start
            </span>
            <span class="legend-item">
              <span class="legend-dot" style="background:#c53030;"></span> Target
            </span>
            <span class="legend-item">
              <span class="legend-dot" style="background:#22c55e;"></span> Path nodes
            </span>
            <span class="legend-item">
              <span class="legend-dot" style="background:#9ca3af;"></span> Expanded neighbors
            </span>
          </div>
          <div style="display:flex;align-items:center;gap:0.4rem;">
            <select id="nodeSelect">
              <option value="">Jump to node…</option>
            </select>
            <button class="btn btn-ghost" id="jumpToNodeBtn">Go</button>
          </div>
        </div>
      </div>
    </section>
  </div>
</div>

<script>
  /* ================================
     GLOBALS / CONSTANTS
  ===================================*/

  const Graph = window.graphology.Graph;
  const SigmaLib = window.Sigma;

  let graph = null;
  let renderer = null;

  const START_COLOR         = "#2779bd";      // blue
  const TARGET_COLOR        = "#c53030";      // red
  const PATH_NODE_COLOR     = "#22c55e";      // green
  const NEIGHBOR_NODE_COLOR = "#9ca3af";      // grey neighbors

  const START_SIZE          = 60;
  const TARGET_SIZE         = 60;
  const PATH_NODE_SIZE      = 35;
  const NEIGHBOR_NODE_SIZE  = 15;

  const NEIGHBOR_EDGE_COLOR = "#6b7280";
  const NEIGHBOR_EDGE_WIDTH = 1.5;
  const PATH_EDGE_COLOR     = "#22c55e";

  const HOVER_DIM_COLOR     = "#374151";

  // Neighbor lookup:
  // { "eminem": { ID, Name, Neighbors: [...] }, ... }
  let neighborLookupIndex = null;
  let artistNameList = []; // for autocomplete

  // Show/hide neighbors
  let showNeighbors = true;

  // Track expansions per anchor node: name -> { nodes: [], edges: [] }
  const expandedByNode = new Map();

  // Path highlight sets
  let currentPath = [];
  const pathNodeSet = new Set();
  const pathEdgeSet = new Set();

  // Hover state
  const reducerState = {
    hoveredNode: null,
    hoveredNeighbors: new Set(),
  };

  // Direction state for clustered randomness
  const clusterSideByNode = new Map();

  // Galaxy camera animation
  let galaxyAnimationFrame = null;
  let galaxyAngle = 0;

  const startInput         = document.getElementById("startArtist");
  const targetInput        = document.getElementById("targetArtist");
  const playlistNameInput  = document.getElementById("playlistName");
  const depthInput         = document.getElementById("depth");
  const resultsDiv         = document.getElementById("results");
  const spinner            = document.getElementById("spinner");
  const toggleNeighborsBtn = document.getElementById("toggleNeighborsBtn");
  const collapseNeighborsBtn = document.getElementById("collapseNeighborsBtn");
  const nodeSelect         = document.getElementById("nodeSelect");
  const jumpToNodeBtn      = document.getElementById("jumpToNodeBtn");

  /* ================================
     SMALL HELPERS
  ===================================*/

  // Support single-track steps (current API) AND multi-track steps (future)
  function safeTracksFromStep(step) {
    if (!step) return [];

    // Single-track format from /search
    if (step.track) {
      return [{
        name: step.track || "",
        url: step.trackURL || "",
        id: step.trackID || "",
        recordingID: step.recordingID || "",
      }];
    }

    // Multi-track format
    if (Array.isArray(step.tracks)) {
      return step.tracks.map(t => ({
        name: t.name || "",
        url: t.url || "",
        id: t.id || "",
        recordingID: t.recordingID || "",
      }));
    }

    return [];
  }

  function computeArtistPositionsFromEdges(edges) {
    const pos = new Map();
    let i = 0;
    edges.forEach(edge => {
      if (edge.from && !pos.has(edge.from)) pos.set(edge.from, i++);
      if (edge.to && !pos.has(edge.to)) pos.set(edge.to, i++);
    });
    return pos;
  }

  function edgeWidthFromCount(count, isPath) {
    const c = count || 1;
    if (isPath) {
      return Math.min(3 + c * 3.5, 32);
    }
    return Math.min(NEIGHBOR_EDGE_WIDTH + c * 1.2, 18);
  }

  /* ================================
     NEIGHBOR LOOKUP + AUTOCOMPLETE
  ===================================*/

  async function loadNeighborLookup() {
    if (neighborLookupIndex) return neighborLookupIndex;

    try {
      const res = await fetch("/NeighborLookup.json?ts=" + Date.now());
      if (!res.ok) {
        console.error("Failed to load NeighborLookup.json:", await res.text());
        neighborLookupIndex = {};
        artistNameList = [];
        return neighborLookupIndex;
      }

      const raw = await res.json();
      const index = {};
      const names = [];

      if (Array.isArray(raw)) {
        raw.forEach(entry => {
          if (!entry || !entry.Name) return;
          const key = entry.Name.toLowerCase();
          if (!index[key]) {
            index[key] = entry;
            names.push(entry.Name);
          }
        });
      } else if (typeof raw === "object" && raw !== null) {
        Object.keys(raw).forEach(k => {
          const entry = raw[k];
          if (!entry) return;
          const name = entry.Name || k;
          const key = name.toLowerCase();
          if (!index[key]) {
            index[key] = entry;
            names.push(name);
          }
        });
      }

      neighborLookupIndex = index;
      artistNameList = names.sort((a, b) => a.localeCompare(b));
      return neighborLookupIndex;
    } catch (err) {
      console.error("Error loading NeighborLookup.json:", err);
      neighborLookupIndex = {};
      artistNameList = [];
      return neighborLookupIndex;
    }
  }

  function findNeighborsEntryByName(name) {
    if (!neighborLookupIndex || !name) return null;
    const lc = name.toLowerCase();
    return neighborLookupIndex[lc] || null;
  }

  async function ensureAutocompleteDataLoaded() {
    if (!neighborLookupIndex) {
      await loadNeighborLookup();
    }
    return artistNameList;
  }

  function createAutocomplete(inputEl) {
    const container = inputEl.closest(".autocomplete-container");
    if (!container) return;
    const listEl = container.querySelector(".autocomplete-list");
    let currentIndex = -1;

    function closeList() {
      listEl.style.display = "none";
      listEl.innerHTML = "";
      currentIndex = -1;
    }

    function renderSuggestions(names, query) {
      listEl.innerHTML = "";
      if (!names.length) {
        closeList();
        return;
      }
      names.forEach((name, idx) => {
        const item = document.createElement("div");
        item.className = "autocomplete-item";
        item.setAttribute("role", "option");
        item.setAttribute("aria-selected", "false");

        const left = document.createElement("div");
        left.className = "autocomplete-left";

        const badge = document.createElement("div");
        badge.className = "artist-badge";
        left.appendChild(badge);

        const nameSpan = document.createElement("div");
        nameSpan.className = "autocomplete-name";

        if (query) {
          const lcName = name.toLowerCase();
          const lcQ = query.toLowerCase();
          const idxMatch = lcName.indexOf(lcQ);
          if (idxMatch >= 0) {
            const before = name.slice(0, idxMatch);
            const middle = name.slice(idxMatch, idxMatch + query.length);
            const after  = name.slice(idxMatch + query.length);
            nameSpan.innerHTML = `${before}<span class="highlight">${middle}</span>${after}`;
          } else {
            nameSpan.textContent = name;
          }
        } else {
          nameSpan.textContent = name;
        }

        left.appendChild(nameSpan);

        const tag = document.createElement("div");
        tag.className = "autocomplete-tag";
        tag.textContent = "Artist";

        item.appendChild(left);
        item.appendChild(tag);

        item.addEventListener("mousedown", (e) => {
          e.preventDefault();
          inputEl.value = name;
          closeList();
        });

        listEl.appendChild(item);
      });

      listEl.style.display = "block";
    }

    async function updateSuggestions() {
      const query = inputEl.value.trim();
      const names = await ensureAutocompleteDataLoaded();

      if (!query) {
        closeList();
        return;
      }

      const lcQ = query.toLowerCase();
      const starts = [];
      const contains = [];

      for (let i = 0; i < names.length; i++) {
        const n = names[i];
        const lcN = n.toLowerCase();
        if (lcN.startsWith(lcQ)) {
          starts.push(n);
        } else if (lcN.includes(lcQ)) {
          contains.push(n);
        }
        if (starts.length + contains.length >= 20) break;
      }

      const suggestions = starts.concat(contains).slice(0, 15);
      renderSuggestions(suggestions, query);
    }

    inputEl.addEventListener("input", () => {
      updateSuggestions();
    });

    inputEl.addEventListener("focus", () => {
      if (inputEl.value.trim()) {
        updateSuggestions();
      }
    });

    inputEl.addEventListener("blur", () => {
      setTimeout(closeList, 120);
    });

    inputEl.addEventListener("keydown", (e) => {
      const items = Array.from(listEl.querySelectorAll(".autocomplete-item"));
      if (!items.length) return;

      if (e.key === "ArrowDown") {
        e.preventDefault();
        currentIndex = (currentIndex + 1) % items.length;
      } else if (e.key === "ArrowUp") {
        e.preventDefault();
        currentIndex = (currentIndex - 1 + items.length) % items.length;
      } else if (e.key === "Enter") {
        if (currentIndex >= 0 && currentIndex < items.length) {
          e.preventDefault();
          const chosen = items[currentIndex].querySelector(".autocomplete-name");
          if (chosen) {
            inputEl.value = chosen.textContent.trim();
          }
          closeList();
        }
        return;
      } else if (e.key === "Escape") {
        closeList();
        return;
      } else {
        return;
      }

      items.forEach((item, idx) => {
        item.setAttribute("aria-selected", idx === currentIndex ? "true" : "false");
      });
    });
  }

  createAutocomplete(startInput);
  createAutocomplete(targetInput);

  /* ================================
     NEIGHBOR EXPANSION / COLLAPSE
  ===================================*/

  function ensureArtistNode(name, start, target, posMap) {
    if (!name) return;

    if (graph.hasNode(name)) {
      graph.setNodeAttribute(name, "role", "path");
      if (name === start) {
        graph.setNodeAttribute(name, "color", START_COLOR);
        graph.setNodeAttribute(name, "size", START_SIZE);
      } else if (name === target) {
        graph.setNodeAttribute(name, "color", TARGET_COLOR);
        graph.setNodeAttribute(name, "size", TARGET_SIZE);
      } else {
        graph.setNodeAttribute(name, "color", PATH_NODE_COLOR);
        graph.setNodeAttribute(name, "size", PATH_NODE_SIZE);
      }
      return;
    }

    let color = PATH_NODE_COLOR;
    let size  = PATH_NODE_SIZE;
    if (name === start) { color = START_COLOR; size = START_SIZE; }
    else if (name === target) { color = TARGET_COLOR; size = TARGET_SIZE; }

    let x = Math.random() * 8 - 4;
    let y = Math.random() * 4 - 2;
    if (posMap && posMap.has(name)) {
      const idx = posMap.get(name);
      x = idx * 8;
      y = Math.sin(idx * 0.7) * 3;
    }

    graph.addNode(name, {
      label: name,
      size,
      color,
      x,
      y,
      role: "path",
    });
  }

  function randomClusterSideForNode(node) {
    if (clusterSideByNode.has(node)) return clusterSideByNode.get(node);

    const start = startInput.value.trim();
    const target = targetInput.value.trim();

    let side;
    if (node === start) {
      side = "left";
    } else if (node === target) {
      side = "right";
    } else {
      const ud = ["up", "down"];
      side = ud[Math.floor(Math.random() * ud.length)];
    }

    clusterSideByNode.set(node, side);
    return side;
  }

  function positionNeighborAroundAnchor(anchor, idx, total, side) {
    const anchorAttrs = graph.getNodeAttributes(anchor);
    const ax = anchorAttrs.x || 0;
    const ay = anchorAttrs.y || 0;

    const t = total <= 1 ? 0 : (idx / (total - 1)) - 0.5;
    const baseRadius = 12 + Math.random() * 3 + Math.log(idx + 2) * 3;
    const jitterR = (Math.random() - 0.5) * 3;
    const jitterAngle = (Math.random() - 0.5) * 0.7;

    let baseAngle;
    switch (side) {
      case "left":  baseAngle = Math.PI;         break;
      case "right": baseAngle = 0;               break;
      case "up":    baseAngle = -Math.PI / 2;    break;
      case "down":  baseAngle =  Math.PI / 2;    break;
      default:      baseAngle = Math.random() * Math.PI * 2;
    }

    const spread = 0.9 + Math.random() * 0.9;
    const angle = baseAngle + t * spread + jitterAngle;
    const radius = baseRadius + jitterR;

    const x = ax + Math.cos(angle) * radius;
    const y = ay + Math.sin(angle) * radius;

    return { x, y };
  }

  function aggregatePathEdges(pathArray) {
    const map = new Map();
    if (!Array.isArray(pathArray)) return [];

    pathArray.forEach(step => {
      if (!step || !step.from || !step.to) return;
      const key = `${step.from}|||${step.to}`;

      if (!map.has(key)) {
        map.set(key, {
          from: step.from,
          to: step.to,
          tracks: [],
        });
      }

      const edge = map.get(key);
      const tracks = safeTracksFromStep(step);
      tracks.forEach(t => edge.tracks.push(t));
    });

    return Array.from(map.values());
  }

  function aggregateNeighborEntries(neighborsArray) {
    const map = new Map();
    if (!Array.isArray(neighborsArray)) return [];

    neighborsArray.forEach(nb => {
      if (!nb) return;

      const nbName = nb.Name || nb.ID;
      if (!nbName) return;

      const key = nbName;

      if (!map.has(key)) {
        map.set(key, {
          id: nb.ID,
          name: nbName,
          tracks: [],
          firstTrack: null,
        });
      }

      const agg = map.get(key);

      if (Array.isArray(nb.Tracks)) {
        nb.Tracks.forEach(t => {
          const trackObj = {
            name: t.Name,
            url: t.PhotoURL,
            id: t.ID,
            recordingID: t.RecordingID,
          };
          agg.tracks.push(trackObj);
          if (!agg.firstTrack) agg.firstTrack = trackObj;
        });
      }
    });

    return Array.from(map.values());
  }

  async function expandNodeNeighbors(anchorName) {
    if (!anchorName) return;

    await loadNeighborLookup();

    const entry = findNeighborsEntryByName(anchorName);
    if (!entry || !Array.isArray(entry.Neighbors) || entry.Neighbors.length === 0) {
      console.warn("No neighbors for", anchorName);
      return;
    }

    if (!graph.hasNode(anchorName)) {
      graph.addNode(anchorName, {
        label: anchorName,
        size: PATH_NODE_SIZE,
        color: PATH_NODE_COLOR,
        x: Math.random() * 6 - 3,
        y: Math.random() * 4 - 2,
        role: "path",
      });
    }

    const aggregatedNeighbors = aggregateNeighborEntries(entry.Neighbors);
    const createdNodes = [];
    const createdEdges = [];

    const side = randomClusterSideForNode(anchorName);
    const total = aggregatedNeighbors.length;

    aggregatedNeighbors.forEach((agg, idx) => {
      const nbName = agg.name;
      if (!nbName) return;

      let isNewNode = false;
      if (!graph.hasNode(nbName)) {
        const pos = positionNeighborAroundAnchor(anchorName, idx, total, side);
        graph.addNode(nbName, {
          label: nbName,
          size: NEIGHBOR_NODE_SIZE,
          color: NEIGHBOR_NODE_COLOR,
          x: pos.x,
          y: pos.y,
          role: "neighbor",
        });
        createdNodes.push(nbName);
        isNewNode = true;
      } else {
        const role = graph.getNodeAttribute(nbName, "role");
        if (!role || role === "neighbor") {
          graph.setNodeAttribute(nbName, "role", "neighbor");
          graph.setNodeAttribute(nbName, "color", NEIGHBOR_NODE_COLOR);
          graph.setNodeAttribute(nbName, "size", NEIGHBOR_NODE_SIZE);
        }
      }

      const trackCount = agg.tracks.length;
      const edgeId = `${anchorName}->${nbName}`;

      const label =
        trackCount === 1
          ? (agg.tracks[0].name || `${trackCount} track`)
          : `${trackCount} tracks`;

      const width = edgeWidthFromCount(trackCount, false);
      const firstTrack = agg.tracks[0] || {};

      if (!graph.hasEdge(edgeId)) {
        graph.addEdgeWithKey(edgeId, anchorName, nbName, {
          label: label,
          color: NEIGHBOR_EDGE_COLOR,
          size: width,
          role: "neighbor",
          tracks: agg.tracks,
          trackCount: trackCount,
          trackURL: firstTrack.url || "",
        });
        createdEdges.push(edgeId);
      } else if (isNewNode) {
        graph.setEdgeAttribute(edgeId, "role", "neighbor");
      }
    });

    if (createdNodes.length || createdEdges.length) {
      const existing = expandedByNode.get(anchorName) || { nodes: [], edges: [] };
      expandedByNode.set(anchorName, {
        nodes: existing.nodes.concat(createdNodes),
        edges: existing.edges.concat(createdEdges),
      });
    }

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  function collapseNodeNeighbors(anchorName) {
    const record = expandedByNode.get(anchorName);
    if (!record) return;

    record.edges.forEach(eId => {
      if (graph.hasEdge(eId)) graph.dropEdge(eId);
    });

    record.nodes.forEach(nId => {
      if (graph.hasNode(nId)) graph.dropNode(nId);
    });

    expandedByNode.delete(anchorName);

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  function toggleNodeNeighbors(anchorName) {
    if (expandedByNode.has(anchorName)) {
      collapseNodeNeighbors(anchorName);
    } else {
      expandNodeNeighbors(anchorName);
    }
  }

  async function expandNeighborsForPath(path) {
    if (!Array.isArray(path)) return;
    const nodeSet = new Set();
    path.forEach(step => {
      if (step.from) nodeSet.add(step.from);
      if (step.to)   nodeSet.add(step.to);
    });

    for (const name of nodeSet) {
      await expandNodeNeighbors(name);
    }
  }

  function collapseAllNeighbors() {
    if (!graph) return;

    graph.forEachEdge((edge, attrs) => {
      if (attrs.role === "neighbor") {
        graph.dropEdge(edge);
      }
    });

    graph.forEachNode((node, attrs) => {
      if (attrs.role === "neighbor") {
        graph.dropNode(node);
      }
    });

    expandedByNode.clear();

    if (renderer) {
      refreshNodeDropdown();
      renderer.refresh();
    }
  }

  /* ================================
     GALAXY CAMERA ANIMATION
  ===================================*/

  function stopGalaxyAnimation() {
    if (galaxyAnimationFrame !== null) {
      cancelAnimationFrame(galaxyAnimationFrame);
      galaxyAnimationFrame = null;
    }
  }

  function startGalaxyAnimation() {
    if (!renderer) return;
    stopGalaxyAnimation();

    const cam = renderer.getCamera();
    galaxyAngle = 0;

    function frame() {
      if (!renderer) return;

      // Read the user's current camera state
      const state = cam.getState();

      // Apply galaxy "drift" only to angle — NOT x/y/ratio
      const newAngle = state.angle + 0.00012;     // very subtle drift

      cam.setState({
        x: state.x,          // preserve user pan
        y: state.y,
        ratio: state.ratio,  // preserve user zoom
        angle: newAngle      // only rotate slowly
      });

      galaxyAnimationFrame = requestAnimationFrame(frame);
    }

    frame();
  }

  /* ================================
     INIT GRAPH + RENDERER
  ===================================*/

  function initGraph(start, target) {
    const container = document.getElementById("graph");

    if (renderer) {
      stopGalaxyAnimation();
      renderer.kill();
      renderer = null;
    }

    graph = new Graph();
    container.innerHTML = "";

    const tooltip = document.createElement("div");
    tooltip.id = "edge-tooltip";
    container.appendChild(tooltip);

    if (start) {
      graph.addNode(start, {
        label: start,
        size: START_SIZE,
        color: START_COLOR,
        x: 0,
        y: 0,
        role: "path",
        labelWeight: "bold"
      });
    }

    renderer = new SigmaLib(graph, container, {
      renderLabels: true,
      renderEdgeLabels: true,
      labelDensity: 0.7,
      labelColor: { color: "#ffffffff" },
      enableEdgeHoverEvents: true,

    });

    refreshNodeDropdown();

    renderer.setSetting("nodeReducer", (node, data) => {
      const res = { ...data };

      if (!showNeighbors && data.role === "neighbor") {
        res.hidden = true;
        return res;
      }

      const isHovered = node === reducerState.hoveredNode;

      if (isHovered) {
        res.color = "#111827";
        res.labelColor = "#22c55eff";
        res.size = data.size * 1.18;
        return res;
      }

      if (reducerState.hoveredNode) {
        if (pathNodeSet.has(reducerState.hoveredNode) && pathNodeSet.size > 0) {
          if (!pathNodeSet.has(node)) {
            res.color = HOVER_DIM_COLOR;
            res.size = data.size * 0.7;
            res.label = "";
          }
        } else {
          const isNeighbor =
            node === reducerState.hoveredNode ||
            reducerState.hoveredNeighbors.has(node);

          if (!isNeighbor) {
            res.color = HOVER_DIM_COLOR;
            res.size = data.size * 0.7;
            res.label = "";
          }
        }
      }

      return res;
    });

    renderer.setSetting("edgeReducer", (edge, data) => {
      const res = { ...data };

      if (!showNeighbors && data.role === "neighbor") {
        res.hidden = true;
        return res;
      }

      if (reducerState.hoveredNode) {
        if (pathNodeSet.has(reducerState.hoveredNode) && pathEdgeSet.size > 0) {
          if (!pathEdgeSet.has(edge)) {
            res.hidden = true;
          }
        } else {
          const [src, dst] = graph.extremities(edge);
          const connected =
            src === reducerState.hoveredNode ||
            dst === reducerState.hoveredNode ||
            reducerState.hoveredNeighbors.has(src) ||
            reducerState.hoveredNeighbors.has(dst);

          if (!connected) {
            res.hidden = true;
          }
        }
      }

      return res;
    });

    renderer.on("enterNode", ({ node }) => {
      reducerState.hoveredNode = node;
      reducerState.hoveredNeighbors = new Set(graph.neighbors(node));
      renderer.refresh({ skipIndexation: true });
    });

    renderer.on("leaveNode", () => {
      reducerState.hoveredNode = null;
      reducerState.hoveredNeighbors.clear();
      renderer.refresh({ skipIndexation: true });
    });

    renderer.on("clickNode", ({ node }) => {
      const label = graph.getNodeAttribute(node, "label") || node;
      toggleNodeNeighbors(label);
    });

    renderer.on("enterEdge", ({ edge }) => {
      const attr = graph.getEdgeAttributes(edge);
      const tracks = attr.tracks || [];

      if (!tracks.length) {
        tooltip.style.display = "none";
        return;
      }

      const firstWithImage = tracks.find(t => t.url) || {};
      const displayTitle =
        tracks.length === 1
          ? (tracks[0].name || "Track")
          : `${tracks.length} tracks`;

      let html = "";
      if (firstWithImage.url) {
        html += `<img src="${firstWithImage.url}">`;
      }
      html += `<div class="title">${displayTitle}</div>`;

      if (tracks.length > 1) {
        const names = tracks
          .map(t => t.name)
          .filter(Boolean)
          .slice(0, 7);
        if (names.length) {
          html += `<div class="title">${names.join("<br>")}</div>`;
        }
      }

      tooltip.innerHTML = html;
      tooltip.style.display = "block";
    });

    renderer.on("leaveEdge", () => {
      tooltip.style.display = "none";
    });

    renderer.on("mousemove", e => {
      const tooltipEl = document.getElementById("edge-tooltip");
      if (!tooltipEl) return;
      tooltipEl.style.left = (e.event.x + 15) + "px";
      tooltipEl.style.top  = (e.event.y + 15) + "px";
    });

    startGalaxyAnimation();
  }

  /* ================================
     PATH RENDERING
  ===================================*/

  function addPathToGraph(path, start, target) {
    if (!graph || !renderer || !Array.isArray(path)) return;

    const aggregatedEdges = aggregatePathEdges(path);
    currentPath = aggregatedEdges;
    pathNodeSet.clear();
    pathEdgeSet.clear();

    const posMap = computeArtistPositionsFromEdges(aggregatedEdges);

    aggregatedEdges.forEach(edge => {
      const from = edge.from;
      const to   = edge.to;
      const tracks = edge.tracks || [];
      if (!from || !to) return;

      const trackCount = tracks.length || 1;
      const width = edgeWidthFromCount(trackCount, true);

      ensureArtistNode(from, start, target, posMap);
      ensureArtistNode(to,   start, target, posMap);

      const edgeId = `${from}->${to}`;

      pathNodeSet.add(from);
      pathNodeSet.add(to);
      pathEdgeSet.add(edgeId);

      const label =
        trackCount === 1
          ? (tracks[0].name || `${trackCount} track`)
          : `${trackCount} tracks`;

      const firstTrack = tracks[0] || {};

      if (graph.hasEdge(edgeId)) {
        graph.setEdgeAttribute(edgeId, "color", PATH_EDGE_COLOR);
        graph.setEdgeAttribute(edgeId, "size", width);
        graph.setEdgeAttribute(edgeId, "role", "path");
        graph.setEdgeAttribute(edgeId, "label", label);
        graph.setEdgeAttribute(edgeId, "tracks", tracks);
        graph.setEdgeAttribute(edgeId, "trackCount", trackCount);
        graph.setEdgeAttribute(edgeId, "trackURL", firstTrack.url || "");
      } else {
        graph.addEdgeWithKey(edgeId, from, to, {
          label: label,
          size: width,
          color: PATH_EDGE_COLOR,
          role: "path",
          tracks: tracks,
          trackCount: trackCount,
          trackURL: firstTrack.url || "",
        });
      }
    });

    refreshNodeDropdown();
    renderer.refresh();
  }

  /* ================================
     DROPDOWN / CAMERA
  ===================================*/

  function refreshNodeDropdown() {
    if (!graph) return;
    const nodes = [];
    graph.forEachNode((node, attrs) => {
      nodes.push(attrs.label || node);
    });
    nodes.sort((a, b) => a.localeCompare(b));

    const current = nodeSelect.value;
    let html = '<option value="">Jump to node…</option>';
    for (const name of nodes) {
      const selected = name === current ? ' selected' : '';
      html += `<option value="${name}"${selected}>${name}</option>`;
    }
    nodeSelect.innerHTML = html;
  }

  function jumpToNode(name) {
    if (!renderer || !graph || !name) return;
    if (!graph.hasNode(name)) return;

    const cam = renderer.getCamera();
    const pos = renderer.getNodeDisplayData(name);
    if (!pos) return;

    cam.animate(
      { x: pos.x, y: pos.y, ratio: 0.12 },
      { duration: 600 }
    );
  }

  /* ================================
     SEARCH WORKFLOW
  ===================================*/

  async function runSearch() {
    const start = startInput.value.trim();
    const target = targetInput.value.trim();
    const depth = Number(depthInput.value || -1);

    if (!start || !target) {
      resultsDiv.innerHTML = "<p class='error'>Start and Target are required.</p>";
      return;
    }

    expandedByNode.clear();
    pathNodeSet.clear();
    pathEdgeSet.clear();
    clusterSideByNode.clear();

    initGraph(start, target);

    resultsDiv.innerHTML = "";
    spinner.style.display = "inline";

    try {
      const res = await fetch("/search", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ start, target, depth }),
      });

      spinner.style.display = "none";

      if (!res.ok) {
        const txt = await res.text();
        resultsDiv.innerHTML = `<p class="error">Request failed: ${txt}</p>`;
        return;
      }

      const data = await res.json();

      if (data.message) {
        resultsDiv.innerHTML = `<p class="muted">${data.message}</p>`;
        return;
      }

      let pathHtml = `<p><strong>Start:</strong> ${data.start}<br>
        <strong>Target:</strong> ${data.target}<br>
        <strong>Hops:</strong> ${data.hops}</p>`;

      if (data.path && data.path.length > 0) {
        pathHtml += `<p class="muted" style="margin-top:0.4rem;">Path (edges weighted by number of tracks):</p><ol class="path-list">`;
        data.path.forEach((step, i) => {
          const from = step.from || "";
          const to   = step.to || "";

          let trackLabel = "";
          if (Array.isArray(step.tracks) && step.tracks.length > 0) {
            trackLabel = step.tracks.map(t => t.name).filter(Boolean).slice(0, 4).join(", ");
            if (step.tracks.length > 4) {
              trackLabel += ` + ${step.tracks.length - 4} more`;
            }
          } else if (step.track) {
            trackLabel = step.track;
          } else {
            trackLabel = "Unknown track";
          }

          pathHtml += `<li>
            ${from} —→ ${to}
            <span class="path-chip">
              <span>${trackLabel}</span>
            </span>
          </li>`;
        });
        pathHtml += `</ol>`;
      }

      resultsDiv.innerHTML = pathHtml;

      addPathToGraph(data.path, data.start, data.target);
      await expandNeighborsForPath(data.path);
      collapseAllNeighbors();
      renderer.refresh();
    } catch (err) {
      spinner.style.display = "none";
      resultsDiv.innerHTML = `<p class="error">Request failed: ${err}</p>`;
    }
  }

  /* ================================
     Create Playlist Workflow
  ===================================*/

  function startAuthAndPlaylist() {
    window.open('/auth', '_blank', 'width=600,height=800');

    const name = playlistNameInput.value.trim() || "My Generated Playlist";
    fetch('/createPlaylist', {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ playlistName: name })
    })
    .then(res => res.json())
    .then(data => {
        console.log("Playlist created:", data);
        if (data.url) {
          alert("Playlist created: " + data.url);
        } else {
          alert("Playlist created (no URL returned)");
        }
    })
    .catch(err => {
        console.error("Error creating playlist:", err);
        alert("Error creating playlist");
    });
  }

  document.getElementById("searchForm").addEventListener("submit", (e) => {
    e.preventDefault();
    runSearch();
  });

  toggleNeighborsBtn.addEventListener("click", () => {
    showNeighbors = !showNeighbors;
    toggleNeighborsBtn.textContent = showNeighbors ? "Hide Neighbors" : "Show Neighbors";
    if (renderer) renderer.refresh({ skipIndexation: true });
  });

  collapseNeighborsBtn.addEventListener("click", () => {
    collapseAllNeighbors();
  });

  jumpToNodeBtn.addEventListener("click", () => {
    const name = nodeSelect.value;
    if (name) jumpToNode(name);
  });
</script>

</body>
</html>
